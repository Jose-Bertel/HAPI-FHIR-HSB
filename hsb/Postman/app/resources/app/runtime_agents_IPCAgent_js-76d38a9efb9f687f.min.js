exports.ids=["runtime_agents_IPCAgent_js"],exports.modules={"./common/channels/IPCChannel.js":function(e,t,n){let r=n("./node_modules/uuid/index.js"),i=n("./common/channels/LinkableChannel.js"),s=Symbol(),o=Symbol();e.exports=class extends i{constructor(e,t,n=r.v4()){if("string"!=typeof n)throw TypeError("Expected IPCChannel id to be a string");super();let i=[],a=()=>{},l=(e,{command:t,eventName:n,data:r})=>{"emit"===t?this.emit(n,r):"ready"===t?c():"destroy"===t?this.destroy():pm.logger.error(`Unrecognized IPCChannel command: ${t}`)},c=()=>{if(i){let t=i;for(let r of(i=null,e.send(n,{command:"ready"}),t))e.send(n,r);a()}};if(t.on(n,l),e.send(n,{command:"ready"}),this.addCleanup(function r(){if(i){let e=setTimeout(()=>{pm.logger.warn("IPCChannel timed out"),c()},2e3);a=()=>{clearTimeout(e),r()}}else t.removeListener(n,l),e.send(n,{command:"destroy"}),a=()=>{}}),"undefined"!=typeof process&&"browser"===process.type){let t=this.destroy.bind(this);e.on("destroyed",t),e.on("render-process-gone",t),this.addCleanup(()=>{e.removeListener("destroyed",t),e.removeListener("render-process-gone",t)})}this[s]=n,this[o]=t=>{i?i.push(t):e.send(n,t)}}receive(e,t){if("string"!=typeof e)throw TypeError("Expected event name to be a string");this.isDestroyed()||this[o]({command:"emit",eventName:e,data:t})}getId(){return this[s]}}},"./common/services/CookieStorageRemoteClient.js":function(e,t,n){let r=n("./node_modules/uuid/index.js").v4;e.exports=class{constructor(e){this.pendingPromises=new Map,this.emit=e}_dispatchAction(e,t){let n=r();if(!this.emit)return t.reject(Error("CookieStorageRemoteClient~_dispatchAction: Emitter not found."));this.emit(Object.assign({id:n},e)),this.pendingPromises.set(n,t)}handleResponse({id:e,data:t,error:n}){e||pm.logger.error("CookieStorageRemoteClient(main)~handleResponse: Response Id not found");let r=this.pendingPromises.get(e);if(this.pendingPromises.delete(e),r){if(n)return r.reject(Error(n));r.resolve(t)}}get(e){return"object"!=typeof e?Promise.reject(Error("CookieStorageRemoteClient(main)~get: Invalid criteria")):new Promise((t,n)=>{this._dispatchAction({action:"get",data:e},{resolve:t,reject:n})})}set(e){return"object"!=typeof e?Promise.reject(Error("CookieStorageRemoteClient(main)~set: Invalid data")):new Promise((t,n)=>{this._dispatchAction({action:"set",data:e},{resolve:t,reject:n})})}remove(e){return"object"!=typeof e?Promise.reject(Error("CookieStorageRemoteClient(main)~remove: Invalid criteria")):new Promise((t,n)=>{this._dispatchAction({action:"remove",data:e},{resolve:t,reject:n})})}}},"./common/services/CryptoService.js":function(e,t,n){let r=n("./node_modules/keytar/lib/keytar.js"),{app:i}=n("electron"),s=i.getName(),o="userKey";e.exports={storeInKeychain:async function(e=s,t,n){try{let i=`${e} (${n})`;await r.setPassword(i,o,t)}catch(e){return pm.logger.error("Error while storing user key in keychain",e),Promise.reject(e)}},retrieveFromKeychain:async function(e=s,t){try{let n=`${e} (${t})`;return await r.getPassword(n,o)}catch(e){return pm.logger.error("Error while retrieving user key from keychain",e),Promise.reject(e)}}}},"./common/services/UnifiedRuntimeService.js":function(e,t,n){let{ServerMethods:r,rpc:i,Channel:s}=n("./node_modules/@postman/runtime/dist/server-methods.js"),{platform:o}=n("./node_modules/@postman/runtime/dist/platform.node.js"),a=n("./utils/getSystemProxy.js"),{homedir:l}=n("os"),{join:c}=n("path"),d=n("./common/utils/postmanFs.js"),{promisify:u}=n("util");e.exports={ServerMethods:{...r,"platform.execute":i({...o,fs:{readFile:async e=>new s(async({incoming:t})=>{let n=new d(c(l(),"Postman","files")),r=u(n.readFile.bind(n)),i=await r(e);t.enqueue(i),t.close()})},proxy:{resolveProxy:async(e,{useSystem:t})=>new s(async({incoming:n})=>{if(!t)return n.enqueue(null),n.close();let r=await new Promise((t,n)=>{a(e,(e,r)=>{if(e)return n(e);t(r?.getProxyUrl())})});n.enqueue(r??null),n.close()})}})}}},"./runtime/agents/IPCAgent.js":function(e,t,n){let{ipcMain:r,session:i}=n("electron"),s=n("./node_modules/serialised-error/index.js"),o=n("./node_modules/lodash/lodash.js"),a=n("./common/services/CookieStorageRemoteClient.js"),l=n("./common/channels/LinkableChannel.js"),c=n("./common/channels/IPCChannel.js"),d=n("./common/services/CryptoService.js"),{VaultManager:u}=n("./common/services/VaultIntegrationService.js"),{ServerMethods:m}=(n("./common/services/VaultScriptService.js"),n("./common/services/UnifiedRuntimeService.js")),{Server:p}=n("./node_modules/@postman/runtime.runtime-rpc-electron/dist/index.js"),v=new Map,f=new Map,g=new Map,h=new Map;function y(e){if(h.has(e))return h.get(e);let t=new u;return h.set(e,t),t}function w(e){return y(e).getOrInitVaultIntegrationManager()}function I(e){return y(e).getOrInitVaultScriptManager()}async function C(e,t,n){let r=w(e);return await r.createVault(t,n)}function b(e,t){return w(e).getVault(t)}e.exports={start:function(e,t){let n=pm.sdk.IPC;async function u(t,n,i){let a;try{let t=String(n).split("."),r=o.get(e,t.slice(0,-1)),s=o.get(e,t);if(!s)throw ReferenceError(`IPCAgent function "${n}" does not exist`);a=await s.apply(r,i)}catch(e){return{error:new s(e)}}if(a instanceof l){let e=new c(t.sender,r);return a.link(e),{result:Object.assign({},a),channel:e.getId()}}return{result:a}}if(n.subscribe("runtime-ipc-command",(t,n,r)=>{if("init"===r.namespace&&"mapClientToWindow"===r.name){let i=r.data&&r.data.windowId,s=f.get(i)||new Set;s.add(n),f.set(i,s),I(n).setEventEmitter((e,n)=>t.reply(e,n),"vault-ipc-event"),pm.eventBus.channel("requester-window-events").subscribe(t=>{if(!t||"window-closed"!==t.type)return;let n=t.windowId,r=f.get(n);r&&0!==r.size&&(r.forEach(t=>{v.delete(t),e.wsBulkDisconnect(Array.from(g.get(t)||[])),g.delete(t),h.delete(t)}),f.delete(n))});return}return"execution"===r.namespace&&"terminate"===r.name?void e.stopRun(r.data.execution,e=>{t.reply("runtime-ipc-event",e)}):"execute"===r.name?void e.startRun(r.data.info,r.data.collection,r.data.variables,r.data.options,v.get(n),h.get(n),e=>{t.reply("runtime-ipc-event",e)}):void("execution"===r.namespace&&"pause"===r.name&&e.pauseRun(r.data.execution,e=>{t.reply("runtime-ipc-event",e)}),"execution"===r.namespace&&"resume"===r.name&&e.resumeRun(r.data.execution,e=>{t.reply("runtime-ipc-event",e)}),"cookie"===r.namespace&&"initializeManager"===r.name&&v.set(n,new a(e=>{t.reply("runtime-ipc-cookie-request",e)})))}),n.subscribe("runtime-ipc-cookie-response",(e,t,n)=>{let r=v.get(t);r&&r.handleResponse(n)}),n.handle("runtime-ipc-cb",async(t,n,r,i,s)=>new Promise(t=>"runtime"===r&&"previewRequest"===i?e.previewRequest(...s,v.get(n),(e,n)=>{t([e,n])}):"oauth2"===r&&"clearAllCookies"===i?e.clearAllElectronCookies(...s,e=>{t([e])}):"files"===r&&"create-temp"===i?e.createTemporaryFile(...s,(e,n)=>{t([e,n])}):"files"===r&&"read"===i?e.readFile(...s,(e,n)=>{t([e,n])}):"files"===r&&"access"===i?e.accessFile(...s,e=>{t([e])}):"files"===r&&"saveResponse"===i?e.saveStreamToFile(...s,(e,n)=>{t([e,n])}):"cloudFiles"===r&&"saveCloudFileLocally"===i?e.saveCloudFileLocally(...s,(e,n)=>{t([e,n])}):"cloudFiles"===r&&"deleteSavedCloudFile"===i?e.deleteSavedCloudFile(...s,(e,n)=>{t([e,n])}):"cloudFiles"===r&&"deleteCloudFileDir"===i?e.deleteCloudFileDir(...s,(e,n)=>{t([e,n])}):"files"===r&&"deleteScriptFileDir"===i?e.deleteScriptFileDir(...s,(e,n)=>{t([e,n])}):"files"===r&&"saveScriptFileLocally"===i?e.saveScriptFileLocally(...s,(e,n)=>{t([e,n])}):"files"===r&&"getDefaultWorkingDir"===i?t([e.defaultWorkingDir]):t([]))),n.subscribe("ws-ipc-command",(t,n,r)=>{let i=g.get(n)||new Set;if("wsConnect"===r.name){e.wsConnect(r.data.connectionId,r.data.connectionConfig,e=>{t.reply("ws-ipc-event",e),"end"===e.event&&(i.delete(e.connectionId),0===i.size?g.delete(n):g.set(n,i))}),i.add(r.data.connectionId),g.set(n,i);return}if("wsDisconnect"===r.name){e.wsDisconnect(r.data.connectionId),i.delete(r.data.connectionId),0===i.size?g.delete(n):g.set(n,i);return}}),n.handle("ws-ipc-cb",async(t,n,r,i,s)=>new Promise(t=>"ws"===r&&"wsSend"===i?e.wsSend(...s,()=>{t([])}):t([]))),n.subscribe("socketIO-ipc-command",(t,n,r)=>{let i=g.get(n)||new Set;if("socketIOConnect"===r.name){e.socketIOConnect(r.data.connectionId,r.data.connectionConfig,e=>{t.reply("socketIO-ipc-event",e),"end"===e.event&&(i.delete(e.connectionId),0===i.size?g.delete(n):g.set(n,i))}),i.add(r.data.connectionId),g.set(n,i);return}if("socketIODisconnect"===r.name){e.socketIODisconnect(r.data.connectionId),i.delete(r.data.connectionId),0===i.size?g.delete(n):g.set(n,i);return}}),n.handle("socketIO-ipc-cb",async(t,n,r,i,s)=>new Promise(t=>"socketIO"===r&&"socketIOPublish"===i?e.socketIOPublish(...s,()=>{t([])}):"socketIO"===r&&"socketIOSubscribe"===i?e.socketIOSubscribe(...s,()=>{t([])}):"socketIO"===r&&"socketIOUnsubscribe"===i?e.socketIOUnsubscribe(...s,()=>{t([])}):t([]))),n.handle("grpc-ipc",async(e,t,n)=>u(e,`grpc.${t}`,n)),n.handle("api-client-ipc",async(e,t,n)=>u(e,t,n)),n.handle("vault-ipc",async(e,t,n,r,i)=>{let o=b(t,i[0]);try{if("status"==r)return[null,o.getUserInformation()];if("logout"==r)return await o?.logout(),[null];if("resolve-secret"==r){let e=await o.isValidSecret(i[1]);return[null,e]}if("resolve-secrets"==r){let e=w(t),n=await e.resolveSecrets(i[0],new AbortController);return[null,n]}if("getUserDetails"==r){let e=await o.fetchAWSConfig();return[null,e]}if("getMFADetails"==r){let e=await o.fetchMFAConfig(i[1]);return[null,e]}if("manualLogin"==r){let e=await o.performLoginFlow(null,i[1]);return[null,e]}if(["saveVaultUserKey","retrieveVaultUserKey"].includes(r))return new Promise(async(e,t)=>{if("saveVaultUserKey"===r){let[n,r,s]=i;d.storeInKeychain(n,r,s).then(()=>e([null])).catch(t)}else if("retrieveVaultUserKey"===r){let[n,r]=i;d.retrieveFromKeychain(n,r).then(t=>e([null,t])).catch(t)}})}catch(e){return[new s(e)]}}),n.subscribe("vault-ipc-command",async(e,t,n)=>{if("init"==n.name){let r=await C(t,n.vaultId,n.data);e.reply("vault-ipc-event",{event:"VAULT_INITIALIZED",vaultId:n.vaultId}),r.on("event",t=>{e.reply("vault-ipc-event",{...t,vaultId:n.vaultId})})}else if("login"==n.name){let r=b(t,n.vaultId);null==r&&e.reply("vault-ipc-event",{event:"error",type:"vault_not_authenticated",vaultId:n.vaultId}),r.handleLogin(t=>{e.reply("vault-ipc-event",{...t,vaultId:n.vaultId})},n.params)}else if("clearCache"===n.name){let e=b(t,n.vaultId);if(null===e)return;e.resetCache()}else if("updateCacheTtl"===n.name){let e=b(t,n.vaultId);if(null===e)return;e.updateCacheTtl(n.params.updatedTtl)}else"reportVaultScriptAccess"===n.name&&I(t).resolveAction(n.data.executionId,n.data.result)}),n.subscribe("postman-runtime-ipc-sync",(t,n,r)=>{if("isInWorkingDir"===n)return t.returnValue=e.isInWorkingDir(...r)}),p){let e={};new p(m,{ipc:{subscribe:n.subscribe.bind(n),handle:n.handle.bind(n),on:(t,r)=>{let i=n.subscribe(t,r);(e[t]??(e[t]=new Map)).set(r,i)},removeListener:(t,n)=>{let r=e[t];r?.delete(n)}}})}else console.warn("Unable to start Electron server for @postman/runtime");let y=i.fromPartition("visualizer");y.setPermissionRequestHandler((e,t,n)=>{n(!1)}),y.on("will-download",e=>{e.preventDefault()}),pm.logger.info("RuntimeIPCAgent~started: Success"),t&&t()}}}};